
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _bound:

bound
=====

<auto-generated stub>

Static methods
--------------

.. parsed-literal::

  :maroon:`def` apply(x: Any): Option\[Double\]




*********

.. parsed-literal::

  :maroon:`def` update(x: Any, y: Double): Unit

 Symbol bounds Tracks the maximum value for a given symbol, along with data about this bound - Fixed = fixed value for all future time (constants or finalized parameters) - Exact = constant value but which may be changed (unfinalized parameters) - Bound = any other upper bound ASSUMPTION: Used only for non-negative size and index calculation User facing: Yes TODO: Should probably change to BigDecimal or something to be accurate Set: bound(Rep[Any]) = Double Set: bound(Rep[Any]) = MBound Set: bound(Rep[Any]) = Option[MBound] Get: bound(Rep[Any])   // Returns Option[Double]. None if undefined.  Helper functions: exact(Double)    // Creates an "exact" bound fixed(Double)    // Creates a "fixed" bound  Extractors: Bound(Rep[Any])  // Returns Option[Double]. Defined for any bound Exact(Rep[Any])  // Returns Option[Double]. Defined only for fixed or exact bounds Fixed(Rep[Any])  // Returns Option[Double]. Defined only for fixed bounds 


*********

.. parsed-literal::

  :maroon:`def` update(x: Any, y: MBound): Unit




*********

.. parsed-literal::

  :maroon:`def` update(x: Any, y: Option\[MBound\]): Unit




