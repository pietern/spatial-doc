

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1. Vector Inner Product &mdash; Spatial 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Spatial 0.1 documentation" href="../index.html"/>
        <link rel="up" title="Examples" href="../examples.html"/>
        <link rel="next" title="Theory" href="../theory.html"/>
        <link rel="prev" title="Examples" href="../examples.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Spatial
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../common.html">Common</a></li>
<li class="toctree-l1"><a class="reference internal" href="../software.html">Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware.html">Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../examples.html">Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">1. Vector Inner Product</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#accelerator-code">Accelerator Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-code">Host Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#final-code">Final Code</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Theory</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Spatial</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../examples.html">Examples</a> &raquo;</li>
        
      <li>1. Vector Inner Product</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/examples/dotproduct.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vector-inner-product">
<h1>1. Vector Inner Product<a class="headerlink" href="#vector-inner-product" title="Permalink to this headline">¶</a></h1>
<p>Inner product (also called dot product) is an extremely simple linear algebra kernel, defined as the
sum of the element-wise products between two vectors of data. For this example, we&#8217;ll assume that the
data in this case are scalar Floats. You could, however, also do the same operations with custom struct types.</p>
<p>Let&#8217;s look at how to write it in Spatial. Let&#8217;s start with the application&#8217;s template. We&#8217;ll first create a method which
takes two Arrays, <cite>a</cite> and <cite>b</cite>:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">spatial._</span>
<span class="k">import</span> <span class="nn">org.virtualized._</span>

<span class="k">object</span> <span class="nc">DotProduct</span> <span class="k">extends</span> <span class="nc">SpatialApp</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">     * Computes the dot product of two arrays on a hardware accelerator.</span>
<span class="cm">     * Arrays a and b should have the same length.</span>
<span class="cm">     */</span>
    <span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
        <span class="n">assert</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
        <span class="o">???</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Entry point for our program. Host CPU starts here.</span>
<span class="cm">     */</span>
    <span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">main</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="o">???</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="accelerator-code">
<h2>Accelerator Code<a class="headerlink" href="#accelerator-code" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s look at the hardware side first. We&#8217;ll define this in the <cite>dotproduct</cite> method.</p>
<p>We first need some global memory to hold our vectors. This memory needs to be big enough to hold the arrays. Since
the size of the arrays is only known at runtime, we&#8217;ll need an ArgIn to pass this to the accelerator:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>
    <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="nc">ArgIn</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="n">setArg</span><span class="o">(</span><span class="n">N</span><span class="o">,</span> <span class="n">len</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">dramA</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">dramB</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="n">setMem</span><span class="o">(</span><span class="n">dramA</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">setMem</span><span class="o">(</span><span class="n">dramB</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We&#8217;ll also need an ArgOut to pass the result of the dot product back to our CPU host:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="nc">ArgOut</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>So far so good. Now we need to compute the dot product of those vectors on the accelerator. To do this,
we need to tile the operation such that we&#8217;re operating on fixed size chunks of data at a time. Dot product is
really simple to tile - we can split the vectors into smaller B-sized vectors, and compute the dot product of each
B chunk. Then we can add up all the dot products across all of those vectors.</p>
<p>In order to do a B-sized dot product, we first need to load some data onto the accelerator:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">val</span> <span class="n">B</span> <span class="k">=</span> <span class="mi">256</span>
    <span class="nc">Accel</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="mf">0.0f</span><span class="o">)</span>
        <span class="nc">Reduce</span><span class="o">(</span><span class="n">result</span><span class="o">)(</span><span class="n">N</span> <span class="n">by</span> <span class="n">B</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
            <span class="k">val</span> <span class="n">sramA</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
            <span class="k">val</span> <span class="n">sramB</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
            <span class="n">sramA</span> <span class="n">load</span> <span class="n">dramA</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">B</span><span class="o">)</span>
            <span class="n">sramB</span> <span class="n">load</span> <span class="n">dramB</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">B</span><span class="o">)</span>

            <span class="o">...</span> <span class="c1">// Inner dot product goes here!</span>

        <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>We&#8217;re using Reduce here because we know the outer loop is a parallelizable reduction. In this Reduce, <cite>i</cite> will have the values
<cite>0, 256, 512, ...</cite>. Using this iterator, we will load our B-sized chunks from dramA into sramA and dramB into sramB
using the range <cite>i::i+B</cite>, which will correspond to address ranges <cite>[0, 255]</cite>, <cite>[256, 511]</cite>, <cite>[512, 767]</cite> and so on.</p>
<p>Now that we have tiles of data, let&#8217;s compute a small dot product:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
            <span class="c1">// Inner dot product</span>
            <span class="nc">Reduce</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">)(</span><span class="n">B</span> <span class="n">by</span> <span class="mi">1</span><span class="o">){</span><span class="n">j</span> <span class="k">=&gt;</span>
                <span class="n">sramA</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">*</span> <span class="n">sramB</span><span class="o">(</span><span class="n">j</span><span class="o">)</span>
            <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here, we&#8217;re saying we&#8217;re doing an element-wise multiplication between sramA and sramB, and adding up all of the elements.</p>
<p>Now let&#8217;s see the entire function, adding the code to return the result back to the host:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>
    <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="nc">ArgIn</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="n">setArg</span><span class="o">(</span><span class="n">N</span><span class="o">,</span> <span class="n">len</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">dramA</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">dramB</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="n">setMem</span><span class="o">(</span><span class="n">dramA</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">setMem</span><span class="o">(</span><span class="n">dramB</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

    <span class="nc">Accel</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="mf">0.0f</span><span class="o">)</span>
        <span class="nc">Reduce</span><span class="o">(</span><span class="n">result</span><span class="o">)(</span><span class="n">N</span> <span class="n">by</span> <span class="n">B</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
            <span class="k">val</span> <span class="n">sramA</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
            <span class="k">val</span> <span class="n">sramB</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
            <span class="n">sramA</span> <span class="n">load</span> <span class="n">dramA</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">B</span><span class="o">)</span>
            <span class="n">sramB</span> <span class="n">load</span> <span class="n">dramB</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">B</span><span class="o">)</span>

            <span class="nc">Reduce</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">)(</span><span class="n">B</span> <span class="n">by</span> <span class="mi">1</span><span class="o">){</span><span class="n">j</span> <span class="k">=&gt;</span>
                <span class="n">sramA</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">*</span> <span class="n">sramB</span><span class="o">(</span><span class="n">j</span><span class="o">)</span>
            <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
        <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
        <span class="n">output</span> <span class="o">:=</span> <span class="n">result</span>   <span class="c1">// Write to a register the host can read</span>
    <span class="o">}</span>
    <span class="n">getArg</span><span class="o">(</span><span class="n">output</span><span class="o">)</span>  <span class="c1">// Read the output register on the host side</span>
<span class="o">}</span>
</pre></div>
</div>
<p>It might seem a bit odd at first that we have the line <cite>{(x,y) =&gt; x + y }</cite> twice. Isn&#8217;t this redundant?
The duplication of this line comes from the fact that we&#8217;ve tiled our computation. The first <cite>x + y</cite> tells us
how to combine any two elements produced by the inner dot product, while the second one tells us how to combine
results from multiple inner dot products. It just so happens that, since this is a tiled Reduce, the combine
function for the two Reduce loops is the same.</p>
<p>So far in this example, we assumed that B (our chunk size) evenly divides the vector size (N). What if this isn&#8217;t the case?
If B doesn&#8217;t divide N, we have an edge case where the remaining number of elements to be operated on is less than B.
The size of the current tile we actually want to compute on then is actually <cite>T = min(B, N - B)</cite>. Let&#8217;s factor that in:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>
    <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="nc">ArgIn</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="n">setArg</span><span class="o">(</span><span class="n">N</span><span class="o">,</span> <span class="n">len</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">dramA</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">dramB</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="n">setMem</span><span class="o">(</span><span class="n">dramA</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">setMem</span><span class="o">(</span><span class="n">dramB</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

    <span class="nc">Accel</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="mf">0.0f</span><span class="o">)</span>
        <span class="nc">Reduce</span><span class="o">(</span><span class="n">result</span><span class="o">)(</span><span class="n">N</span> <span class="n">by</span> <span class="n">B</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
            <span class="k">val</span> <span class="n">sramA</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
            <span class="k">val</span> <span class="n">sramB</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
            <span class="k">val</span> <span class="n">T</span> <span class="k">=</span> <span class="n">min</span><span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">B</span><span class="o">)</span>     <span class="c1">// Edge case handling</span>
            <span class="n">sramA</span> <span class="n">load</span> <span class="n">dramA</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">T</span><span class="o">)</span>  <span class="c1">// Now loads T elements</span>
            <span class="n">sramB</span> <span class="n">load</span> <span class="n">dramB</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">T</span><span class="o">)</span>  <span class="c1">// Now loads T elements</span>

            <span class="nc">Reduce</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">)(</span><span class="n">T</span> <span class="n">by</span> <span class="mi">1</span><span class="o">){</span><span class="n">j</span> <span class="k">=&gt;</span>   <span class="c1">// Now iterates over T</span>
                <span class="n">sramA</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">*</span> <span class="n">sramB</span><span class="o">(</span><span class="n">j</span><span class="o">)</span>
            <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
        <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
        <span class="n">output</span> <span class="o">:=</span> <span class="n">result</span>   <span class="c1">// Write to a register the host can read</span>
    <span class="o">}</span>
    <span class="n">getArg</span><span class="o">(</span><span class="n">output</span><span class="o">)</span>  <span class="c1">// Read the output register on the host side</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="host-code">
<h2>Host Code<a class="headerlink" href="#host-code" title="Permalink to this headline">¶</a></h2>
<p>To call our accelerator, all we need now are some arrays to operate on. Let&#8217;s just load these from some files called
&#8220;vectorA.csv&#8221; and &#8220;vectorB.csv&#8221;:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">main</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">loadCSV1D</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="s">&quot;vectorA.csv&quot;</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">loadCSV1D</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="s">&quot;vectorB.csv&quot;</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Product of A and B: &quot;</span> <span class="o">+</span> <span class="n">prod</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>That&#8217;s all for this example!</p>
</div>
<div class="section" id="final-code">
<h2>Final Code<a class="headerlink" href="#final-code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">spatial._</span>
<span class="k">import</span> <span class="nn">org.virtualized._</span>

<span class="k">object</span> <span class="nc">DotProduct</span> <span class="k">extends</span> <span class="nc">SpatialApp</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">     * Computes the dot product of two arrays on a hardware accelerator.</span>
<span class="cm">     * Arrays a and b should have the same length.</span>
<span class="cm">     */</span>
    <span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">{</span>
        <span class="n">assert</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>
        <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="nc">ArgIn</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
        <span class="n">setArg</span><span class="o">(</span><span class="n">N</span><span class="o">,</span> <span class="n">len</span><span class="o">)</span>

        <span class="k">val</span> <span class="n">dramA</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">dramB</span> <span class="k">=</span> <span class="nc">DRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
        <span class="n">setMem</span><span class="o">(</span><span class="n">dramA</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
        <span class="n">setMem</span><span class="o">(</span><span class="n">dramB</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

        <span class="nc">Accel</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="mf">0.0f</span><span class="o">)</span>
            <span class="nc">Reduce</span><span class="o">(</span><span class="n">result</span><span class="o">)(</span><span class="n">N</span> <span class="n">by</span> <span class="n">B</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
                <span class="k">val</span> <span class="n">sramA</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
                <span class="k">val</span> <span class="n">sramB</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="n">B</span><span class="o">)</span>
                <span class="k">val</span> <span class="n">T</span> <span class="k">=</span> <span class="n">min</span><span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">B</span><span class="o">)</span>
                <span class="n">sramA</span> <span class="n">load</span> <span class="n">dramA</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">T</span><span class="o">)</span>
                <span class="n">sramB</span> <span class="n">load</span> <span class="n">dramB</span><span class="o">(</span><span class="n">i</span><span class="o">::</span><span class="n">i</span><span class="o">+</span><span class="n">T</span><span class="o">)</span>

                <span class="nc">Reduce</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">)(</span><span class="n">T</span> <span class="n">by</span> <span class="mi">1</span><span class="o">){</span><span class="n">j</span> <span class="k">=&gt;</span>
                    <span class="n">sramA</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">*</span> <span class="n">sramB</span><span class="o">(</span><span class="n">j</span><span class="o">)</span>
                <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
            <span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
            <span class="n">output</span> <span class="o">:=</span> <span class="n">result</span>   <span class="c1">// Write to a register the host can read</span>
        <span class="o">}</span>
        <span class="n">getArg</span><span class="o">(</span><span class="n">output</span><span class="o">)</span>  <span class="c1">// Read the output register on the host side</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Entry point for our program. Host CPU starts here.</span>
<span class="cm">     */</span>
    <span class="nd">@virtualize</span> <span class="k">def</span> <span class="n">main</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">loadCSV</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="s">&quot;vectorA.csv&quot;</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">loadCSV</span><span class="o">[</span><span class="kt">Float</span><span class="o">](</span><span class="s">&quot;vectorB.csv&quot;</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="n">dotproduct</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

        <span class="n">println</span><span class="o">(</span><span class="s">&quot;Product of A and B: &quot;</span> <span class="o">+</span> <span class="n">prod</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Next example: <span class="xref doc">outerproduct</span></p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../theory.html" class="btn btn-neutral float-right" title="Theory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../examples.html" class="btn btn-neutral" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017,Stanford PPL.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>