
1. Hello, Spatial!
==================
Now that you have cloned all of the code and set all of your environment variables, let's look at how to write, build, and run your first Spatial app!

Spatial App Structure
---------------------

All Spatial programs have a few basic components. The following code example shows each of those components::

    // 1. Imports
    import org.virtualized._
    import spatial._

    // 2. The Scala object which can be compiled and staged
    object ArgInOut extends SpatialApp {
      import IR._

      // 3. This method, main, is called on program startup.
      // Spatial apps are required to use the "@virtualize" macro
      @virtualize
      def main() {

        // 4. Declare command line input arguments
        val N = args(0).to[Int]

        // 5. Declare the interface between host and accelerator
        val x = ArgIn[Int]
        val y = ArgOut[Int]

        // 6. Explicitly communicate the input to the hardware
        setArg(x, N)

        // 7. Specify algorithm to be done on hardware
        Accel {
          y := x + 4
        }

        // 8. Explicitly pull data off of the hardware
        val result = getArg(y)

        // 9. Specify algorithm to be done in software
        val gold = N + 4
        println("expected: " + gold)
        println("result: " + result)
      }
    }


This code can be found in: ``$SPATIAL_HOME/apps/src/ArgInOutTest.scala``


Because Spatial is a DSL for programming reconfigurable *hardware*, we will begin with the hardware equivalent of "Hello, World."
In this app, the hardware reads some numeric argument from an off-chip source and then echoes it back to an off-chip destination.

Spatial apps are always divided into two parts: the portion of code that runs on the host CPU and the portion of code that gets generated as an accelerator.
In this example, the entirety of the app exists inside of **(3)** ``main()``, and the subset of code inside of the scope prefixed with **(7)** ``Accel`` is the hardware part of the app.

In the ArgInOut app, we start with three declarations above the ``Accel`` scope:

**(4)** We first declare *N* to be one of the command-line input arguments at run-time by setting it equal to ``args(0)``.
We must also explicitly cast this :doc:`../cpu/string` argument to a Spatial type by appending ``.to[Int]``.

**(5)** We then, declare *x* to be an :doc:`ArgIn <../accel/memories/reg>` of type :doc:`Int <../common/fixpt>` and
*y* to be an :doc:`ArgOut <../accel/memories/reg>` of type :doc:`Int <../common/fixpt>`.

In addition to ArgIns and ArgOuts, Spatial offers :doc:`../accel/memories/dram`, which represents an off-chip memory that
both the host and the accelerator can read from and write to.


**(6)** Now that we have both a value that represents an ArgIn and another value which reads some value from the command-line at runtime,
we must connect the two with ``setArg(<HW val>, <SW val>)``.
Similarly, we can connect a DRAM to an array with ``setMem(<HW array>, <SW array>)``.

**(7)** Next, we specify the ``Accel`` block.
In this particular app, we simply want to add the number `4` to whatever input argument is read in.
To do this, we just use the Reg ``:=`` operation to write our ArgOut register with ``x + 4``.
In later sections, you will learn what other operations and building blocks Spatial exposes to the developer.


**(8)**  After the ``Accel`` block, we return to the host code section of an app that will interact with the result generated by the hardware.
Specifically, we start by assigning the ArgOut register to a software variable with ``getArg(<HW val>)``.
Similarly, we can assign a DRAM to a software array with ``getMem(<HW array>)``.

**(9)** Finally, we add any debug and validation code to check if the accelerator is performing as expected.
In this example, we compute the result we expect the hardware to give, and then :doc:`print <../cpu/debug>` both this number and the number we actually got.

----------------

Compiling
---------

.. highlight:: bash

Currently, you should edit and place apps inside of your `${SPATIAL_HOME}/apps/src/` directory.
**Any time you change an app, you must remake Spatial with:** ::

    cd ${SPATIAL_HOME} && make apps

Once you have a complete Spatial app, the next step is to compile and run it.
Currently, there are two available targets: Scala (for simple functional simulation) and Chisel (for FPGA).

**Compiling to Scala**

Targetting Scala is the quickest way to simulate your app and test for basic functional correctness.
It also allows ``println`` calls in code that exists inside the ``Accel`` block.
You should use this backend if you are debugging things at the algorithm level.
In order to compile and simulate for the Scala backend, run::

    cd ${SPATIAL_HOME}/
    bin/spatial <app name> --scala # + other options

The "<app name>" refers to the name of the ``object``. In our app above, for example, the app name is "ArgInOut".
See the "Testing" section below for a guide on how to test the generated app



**Compiling to Chisel**

Targeting Chisel will let you compile your app down into Berkeley's Chisel language, which eventually compiles down to Verilog.
It also allows you to debug your app at the clock-cycle resolution. In order to compile with the Chisel backend, run the following::

    cd ${SPATIAL_HOME}
    bin/spatial <app name> --chisel # + other options



Synthesizing and Testing
------------------------

After you have used the ``bin/spatial`` script to compile the app, navigate to the generated code
directory to test the app.  By default, this is ``${SPATIAL_HOME}/gen/<app name>``.  You will see some
files and directories in this folder that correspond to the code that Spatial created for the various
target platforms.
For the Chisel backend, here is a rough breakdown of what the important files are:

+---------------------------+---------------------------------------------------------------------------+
| chisel/TopTrait.scala     | Main trait where all of the controller and dataflow connections are made  |
+---------------------------+---------------------------------------------------------------------------+
| chisel/IOModule.scala     | Interface between FPGA accelerator and CPU                                |
+---------------------------+---------------------------------------------------------------------------+
| chisel/BufferControlCxns  | Connections for all N-buffered memories in the design                     |
+---------------------------+---------------------------------------------------------------------------+
| chisel/resources/\*.scala | Files for all of the fundamental building blocks of a Spatial app         |
+---------------------------+---------------------------------------------------------------------------+
| cpp/TopHost.scala         | Contains the Application method where all CPU code is generated           |
+---------------------------+---------------------------------------------------------------------------+
| controller_tree.html      | Helpful diagram for showing the hierarchy of control nodes in your app    |
+---------------------------+---------------------------------------------------------------------------+


In order to finally test this code, you must compile the backend code itself. In order to do so, run the following::

    cd ${SPATIAL_HOME}/gen/<app name>
    make sim
    bash run.sh <arguments>

If using the Chisel backend, this will turn any Chisel code into Verilog, which then gets turned into C++ through Verilator.
It also compiles the Spatial-generated C++.  Finally, the ``run.sh`` script executes the entire application with communication between the hardware and CPU and returns the result.
If using the Scala backend, this will just test the Scala code on your machine.

After running a Chisel app, you can see the waveforms generated in the ``test_run_dir/app.Launcher####`` folder, with the `.vcd` extension for further debugging

The "<arguments>" should be a space-separated list, fully enclosed in quotes.  For example, an app that takes arguments 192 96 should be run with::

	bash run.sh "192 96"



Now that you have built and tested your first app, there are a lot more things you can do in Spatial!
You may already have an algorithm in mind that you want to write, or you may want to keep exploring to get a sense of what the language can do.
Feel free to poke around the apps we have written in ``${SPATIAL_HOME}/apps/src`` for examples of apps.
You may also find it useful to copy/paste one of our existing apps and start tweaking it to get more interesting algorithms.
If you run into any questions or issues, you can always post on our [forum](https://groups.google.com/forum/#!forum/spatial-lang-users).

Note that since the language is still actively under development, if one of our apps does not work and you think it should,
you should check the regression test status at the top of this README for a quick reference whether or not the app you are playing with is expected to work at the moment.


Next, :doc:`learn how to build more complicated Spatial programs <model>`.

