

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. Controller Templates &mdash; Spatial 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Spatial 0.1 documentation" href="../index.html"/>
        <link rel="up" title="Tutorial" href="../tutorial.html"/>
        <link rel="next" title="5. Transfer Templates" href="transfers.html"/>
        <link rel="prev" title="3. Memory Templates" href="memories.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Spatial
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../common.html">Common</a></li>
<li class="toctree-l1"><a class="reference internal" href="../software.html">Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware.html">Hardware</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorial.html">Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="starting.html">0. Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="helloworld.html">1. Hello, Spatial!</a></li>
<li class="toctree-l2"><a class="reference internal" href="model.html">2. The Spatial Programming Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="memories.html">3. Memory Templates</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4. Controller Templates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#accel-block">Accel Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-nodes">Control Nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-tags">Control Tags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="transfers.html">5. Transfer Templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="dse.html">6. Design Space Exploration with Spatial</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Theory</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Spatial</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../tutorial.html">Tutorial</a> &raquo;</li>
        
      <li>4. Controller Templates</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorial/controllers.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="controller-templates">
<h1>4. Controller Templates<a class="headerlink" href="#controller-templates" title="Permalink to this headline">¶</a></h1>
<div class="section" id="accel-block">
<h2>Accel Block<a class="headerlink" href="#accel-block" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Accel</span></code> blocks scope out any code that will run on the hardware accelerator.
This is where you should specify the dataflow-heavy part of the algorithm using a hierarchy of control nodes and primitive operations.</p>
</div>
<div class="section" id="control-nodes">
<h2>Control Nodes<a class="headerlink" href="#control-nodes" title="Permalink to this headline">¶</a></h2>
<p>A control node is essentially some variety of a loop, with extra semantic information for the compiler.
As with imperative <em>for</em> loops, control nodes scope out a section of code that runs for some given number of iterations.</p>
<p>It is best to think of the <cite>Accel</cite> block as a hierarchy of control nodes, where each control node contains either a
list of other control nodes, or a list of primitive operations.</p>
<p>The control nodes currently available are:</p>
<p><strong>Foreach</strong></p>
<p>The <em>Foreach</em> controller is similar to a <em>for</em> loop. Significantly, however, unless explicitly told otherwise, the compiler
will assume each iteration of <em>Foreach</em> is independent, and will attempt to parallelize and pipeline the body.
<em>Foreach</em> has no usable return value.</p>
<p>A <em>Foreach</em> can be created using:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="c1">// Some operations or other controllers</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here, the variable <code class="docutils literal"><span class="pre">i</span></code> represents the iterator, which will take on values 0 through N as the counter progresses.</p>
<p>We can also make a 2 dimensional loop:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">,</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// Some other operations</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This code says that we are iterating over a two dimensional, <em>M</em> x <em>N</em> space, where <em>M</em> is the size of the outer dimension,
and <em>N</em> is the size of the inner dimension. In the loop, <code class="docutils literal"><span class="pre">i</span></code> will take values 0 through M and <code class="docutils literal"><span class="pre">j</span></code> will take values 0 through N (M times).</p>
<p><strong>Reduce</strong></p>
<p>The <em>Reduce</em> node takes many scalar values and combines them into one value using some associative operator.
Like <em>Foreach</em>, unless otherwise disabled, the compiler will attempt to automatically pipeline and parallelize <em>Reduce</em> nodes.
A <em>Reduce</em> node consists of a <em>map</em> function, which is responsible for producing the values that will be used in the reduction, and
a <em>reduction</em> function to describe how the values should be combined.</p>
<p><em>Reduce</em> returns the accumulator which, at the end of the loop, will contain the final result of the reduction.</p>
<p>For example, suppose we want to add up all of the elements in a local <a class="reference internal" href="../accel/memories/sram.html"><span class="doc">SRAM</span></a> scratchpad.
In this case, the <em>map</em> function should tell the hardware to load an element from the memory and the <em>reduction</em> function
tells the hardware to perform an addition to combine elements:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reduce</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="n">data</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal"><span class="pre">i</span></code> is again the loop iterator, which will take values 0 through N.  The <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> here don&#8217;t represent
any specific values. Instead, they represent any two values which are produced from the <em>map</em>. Spatial supports this syntax because,
unlike imperative updates, this functional representation allows the compiler to easily identify, analyze, and duplicate the reduction function.</p>
<p><em>Reduce</em> can also take an explicit accumulator:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="nc">Reduce</span><span class="o">(</span><span class="n">result</span><span class="o">)(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>Or an explicit identity value (the value which does not change the output when combined using the reduction function):</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>Both of these have the same behavior as the previous example. In some cases, supplying an explicit identity value
can decrease the size of the generated logic slightly.</p>
<p><strong>Fold</strong></p>
<p><em>Fold</em> is similar to <em>Reduce</em>, but it takes an initial value rather than an identity value. This initial value is
combined with the rest of the produced values. Alternatively, if <em>Fold</em> is given an explicit accumulator, the
current value of the accumulator will be combined when calculating the final result.</p>
<p>The same example as above, now using <em>Fold</em> with an initial value:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Fold</span><span class="o">(</span><span class="mi">10</span><span class="o">)(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="n">data</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This will produce 10 + (the sum of the contents of <code class="docutils literal"><span class="pre">data</span></code>).</p>
<p>With an explicit accumulator:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
<span class="k">val</span> <span class="n">accum</span> <span class="k">=</span> <span class="nc">Reg</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">accum</span> <span class="o">:=</span> <span class="mi">10</span>

<span class="nc">Fold</span><span class="o">(</span><span class="n">accum</span><span class="o">)(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="n">data</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Again, this will produce 10 + (the sum of the contents of <code class="docutils literal"><span class="pre">data</span></code>), since <code class="docutils literal"><span class="pre">accum</span></code> holds 10 when the <em>Fold</em> begins.</p>
<p><strong>MemReduce</strong></p>
<p>Also occasionally referred to as &#8220;Block Reduce&#8221;, <em>MemReduce</em> describes the reduction <em>across</em> multiple local memories.
Like <em>Reduce</em>, <em>MemReduce</em> requires both a <em>map</em> and a <em>reduction</em> function. However, in <em>MemReduce</em>, the <em>map</em>
describes the creation and population of a local memory (typically an <a class="reference internal" href="../accel/memories/sram.html"><span class="doc">SRAM</span></a>).
The <em>reduction</em> function still operates on scalars, and is used to combine local memories together element-wise.
Unlike <em>Reduce</em>, <em>MemReduce</em> always requires an explicit accumulator.
Unless otherwise disabled, the compiler will then try to parallelize both the creation of this memory and the reduction
of each of these memories into a single accumulator.</p>
<p>Let&#8217;s look at an example where we use <em>MemReduce</em> to combine <em>M</em> sequences of the numbers 0 ... <em>N</em>-1:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">accum</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
<span class="nc">MemReduce</span><span class="o">(</span><span class="n">accum</span><span class="o">)(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">sequence</span> <span class="k">=</span> <span class="nc">SRAM</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">N</span><span class="o">)</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">){</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="n">sequence</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="k">=</span> <span class="n">j</span> <span class="o">}</span>
    <span class="n">sequence</span>
<span class="o">}{(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Clearly this is a silly example, since we could have computed the final result of <code class="docutils literal"><span class="pre">accum</span></code> without all this effort.
However, there are plenty of algorithms (e.g. gradient descent) which have accumulation of identical N-dimensional arrays.</p>
<p><strong>Parallel</strong></p>
<p>Unlike the other control nodes, <em>Parallel</em> does not specify a loop, but simply tells the compiler to schedule
any inner control nodes in a fork-join manner.</p>
<p>For instance:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nc">Parallel</span> <span class="o">{</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Loop #1</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">){</span> <span class="n">j</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Loop #2</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In this example, Loop #1 and Loop #2 will be run at the same time, and the <em>Parallel</em> controller will complete
only when both are done.</p>
<p>Parallel will be soon be deprecated for general use as the scheduling algorithms in the Spatial compiler improve.</p>
</div>
<div class="section" id="control-tags">
<h2>Control Tags<a class="headerlink" href="#control-tags" title="Permalink to this headline">¶</a></h2>
<p>While the oracle compiler is a nice dream, it can often be difficult for a compiler to discover ALL relevant information
about a program. Spatial offers a few annotation tags when creating controllers to allow users to specify how
a controller&#8217;s inner body should be scheduled.</p>
<p>Controller tags are specified using prefix syntax, e.g. <code class="docutils literal"><span class="pre">&lt;Tag&gt;.&lt;Controller&gt;</span></code>.</p>
<p><strong>Pipe</strong></p>
<p><em>Pipe</em> is the default tag for controllers, and doesn&#8217;t usually need to be specified. This tag tells the compiler that
the stages of the controller can be overlapped in a pipelined fashion. If the controller contains other controllers within it,
this means that these inner controllers will be executed using coarse-grained pipeline scheduling.
Additionally, <em>Pipe</em> tells the compiler it may attempt to parallelize the loop by unrolling it in space.</p>
<p>When multiple stages communicate through an <a class="reference internal" href="../accel/memories/sram.html"><span class="doc">SRAM</span></a> in a <em>Pipe</em> controller, the compiler will
automatically buffer and bank memories as necessary to maximize throughput.</p>
<p>For example, suppose a <em>Foreach</em> contains two stages:</p>
<div class="highlight-Scala"><div class="highlight"><pre><span></span><span class="nc">Pipe</span><span class="o">.</span><span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Stage 0</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">){</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Stage 1</span>
<span class="o">}</span>
</pre></div>
</div>
<p>When executing, Stage 0 will execute with the first value of the counter.
When Stage 0 finishes, the counter for the control node will increment and Stage 0 will then begin executing again with this new counter value.
At the same time, it will pass its old counter value to Stage 1, which will begin to execute its first iteration.</p>
<p><strong>Sequential</strong></p>
<p>The <em>Sequential</em> tag tells the compiler not to attempt to parallelize or to pipeline inner computation. In this
scheduling mode, the controller&#8217;s counter will only increment when it&#8217;s last stage is complete.
This tag is needed primarily when your algorithm contains long loop-carry dependencies that cannot be optimized away.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">Sequential</span><span class="o">.</span><span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Stage 0</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">){</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Stage 1</span>
<span class="o">}</span>
</pre></div>
</div>
<p><strong>Stream</strong></p>
<p>The <em>Stream</em> tag tells the compiler to overlap inner computation in a fine-grained, streaming fashion. In controllers
which contain multiple control stages, this implies that communication is being done through <a class="reference internal" href="../accel/memories/fifo.html"><span class="doc">FIFOs</span></a>
at an element-wise level.</p>
<p>Communication across stages within <em>Stream</em> controllers through any memory except FIFOs is currently disallowed.
Note that this may change as the language evolves.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">Stream</span><span class="o">.</span><span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">fifo</span> <span class="k">=</span> <span class="nc">FIFO</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">32</span><span class="o">)</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">N</span><span class="o">){</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">fifo</span><span class="o">.</span><span class="n">enq</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">}</span>    <span class="c1">// Stage 0</span>
    <span class="nc">Foreach</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">M</span><span class="o">){</span> <span class="n">j</span> <span class="k">=&gt;</span> <span class="n">fifo</span><span class="o">.</span><span class="n">deq</span><span class="o">()</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// Stage 1</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now let&#8217;s <a class="reference internal" href="transfers.html"><span class="doc">look at the specialized memory transfer templates in Spatial</span></a></p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="transfers.html" class="btn btn-neutral float-right" title="5. Transfer Templates" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="memories.html" class="btn btn-neutral" title="3. Memory Templates" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017,Stanford PPL.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>